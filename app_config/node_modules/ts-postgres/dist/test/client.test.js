"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const net_1 = require("net");
const globals_1 = require("@jest/globals");
const helper_1 = require("./helper");
const index_1 = require("../src/index");
// Adjust for benchmarking mode.
const benchmarkEnabled = process.env.NODE_ENV === 'benchmark';
const timedQueryTime = benchmarkEnabled ? 5000 : 500;
function makeRandomizer(seed) {
    return (n) => {
        const x = Math.sin(seed++) * 10000;
        const r = x - Math.floor(x);
        return Math.floor(r * Math.floor(n));
    };
}
function secondsFromHrTime(time) {
    const d = process.hrtime(time);
    return d[0] + d[1] / (Math.pow(10, 9));
}
function unsafeToSimpleQuery(query) {
    let text = query.text;
    const params = (query.values || []).map(String);
    for (let i = 0; i < params.length; i++) {
        const param = params[i];
        text = text.replace('$' + (i + 1), param);
    }
    return { text };
}
function testSelect(testQuery, batchSize, doReplaceArgs) {
    /* eslint-disable-next-line prefer-const */
    let { name, query } = (() => {
        switch (testQuery) {
            case 1 /* TestQuery.Array */: return {
                name: 'Array',
                query: {
                    // tslint:disable-next-line
                    text: 'select (select array_agg(i) from generate_series(1, 100) as s(i)) from generate_series(1, 100)'
                }
            };
            case 0 /* TestQuery.PgType */: return {
                name: 'PgType',
                query: {
                    // tslint:disable-next-line
                    text: 'select typname, typnamespace, typowner, typlen, typbyval, typcategory, typispreferred, typisdefined, typdelim, typrelid, typelem, typarray from pg_type where typtypmod = $1 and typisdefined = $2',
                    values: [-1, true]
                }
            };
        }
    })();
    if (doReplaceArgs) {
        query = unsafeToSimpleQuery(query);
    }
    (0, helper_1.testWithClient)(`SQL: Select (${testQuery}; ${doReplaceArgs}; batch size: ${batchSize})`, (client) => __awaiter(this, void 0, void 0, function* () {
        globals_1.expect.assertions(1);
        const go = (time) => __awaiter(this, void 0, void 0, function* () {
            let queries = 0;
            let acknowledged = 0;
            let results = 0;
            const startTime = process.hrtime();
            const secs = time / 1000;
            while (true) {
                const d = secs - secondsFromHrTime(startTime);
                if (d < 0) {
                    break;
                }
                let i = batchSize;
                const promises = [];
                while (i--) {
                    const p = client.query(query.text, query.values).then((result) => {
                        acknowledged += 1;
                        results += result.rows.length;
                    });
                    queries++;
                    promises.push(p);
                }
                yield Promise.all(promises);
            }
            const d = secondsFromHrTime(startTime);
            return [queries, results, queries - acknowledged, d];
        });
        yield go(timedQueryTime / 10);
        const [queries, rows, diff, time] = yield go(timedQueryTime);
        const round = (n) => { return Math.round(n / time); };
        if (benchmarkEnabled) {
            const secs = (Math.round(time * 100) / 100).toFixed(2) + ' secs';
            const q = round(queries);
            const r = round(rows);
            console.log(`[${name}] Q/sec: ${q}; ` +
                `R/sec: ${r} (${secs}); ` +
                `B: ${batchSize}`);
        }
        (0, globals_1.expect)(diff).toEqual(0);
    }));
}
(0, globals_1.describe)('Timeout', () => {
    (0, globals_1.test)('Connection timeout', () => __awaiter(void 0, void 0, void 0, function* () {
        const server = (0, net_1.createServer)();
        yield new Promise((resolve) => {
            server.listen(0, "localhost", 1, () => { resolve(undefined); });
        });
        const sockets = new Set();
        server.on('connection', (socket) => {
            sockets.add(socket);
            server.once('close', () => {
                sockets.delete(socket);
            });
        });
        (0, globals_1.expect)(server.listening).toBeTruthy();
        const address = server.address();
        const client = new index_1.Client({
            connectionTimeout: 250,
            host: process.env["PGHOST"] || address.address,
            port: address.port,
        });
        yield (0, globals_1.expect)(client.connect()).rejects.toThrow(/Timeout after 250 ms/);
        yield client.end();
        for (const socket of sockets.values()) {
            socket.destroy();
        }
        return new Promise((resolve) => {
            server.close(() => {
                resolve(undefined);
            });
        });
    }));
});
(0, globals_1.describe)('Query', () => {
    (0, helper_1.testWithClient)('Without parameters', (client) => __awaiter(void 0, void 0, void 0, function* () {
        globals_1.expect.assertions(1);
        const result = yield client.query('select 1');
        (0, globals_1.expect)(result.rows.length).toEqual(1);
    }));
    (0, helper_1.testWithClient)('With parameters', (client) => __awaiter(void 0, void 0, void 0, function* () {
        globals_1.expect.assertions(1);
        const result = yield client.query('select $1::int', [1]);
        (0, globals_1.expect)(result.rows.length).toEqual(1);
    }));
    (0, helper_1.testWithClient)('Named portal', (client) => __awaiter(void 0, void 0, void 0, function* () {
        globals_1.expect.assertions(1);
        const result = yield client.query('select $1::int', [1]);
        (0, globals_1.expect)(result.rows.length).toEqual(1);
    }));
    (0, helper_1.testWithClient)('Custom value type reader', (client) => __awaiter(void 0, void 0, void 0, function* () {
        globals_1.expect.assertions(5);
        client.config.types = new Map([
            [index_1.DataType.Int4, (buffer, start, end, format, encoding) => {
                    const value = buffer.readInt32BE(start);
                    (0, globals_1.expect)(end - start).toEqual(4);
                    (0, globals_1.expect)(value).toEqual(1);
                    (0, globals_1.expect)(format).toEqual(index_1.DataFormat.Binary);
                    (0, globals_1.expect)(encoding).toEqual('utf-8');
                    return 1;
                }]
        ]);
        const result = yield client.query('select 1::int4');
        (0, globals_1.expect)(result.rows.length).toEqual(1);
    }));
    (0, helper_1.testWithClient)('Name transform', (client) => __awaiter(void 0, void 0, void 0, function* () {
        globals_1.expect.assertions(1);
        const query = { text: 'select 1 as foo', transform: (s) => s.toUpperCase() };
        const result = yield client.query(query);
        (0, globals_1.expect)(result.names).toEqual(['FOO']);
    }));
    (0, helper_1.testWithClient)('Listen/notify', (client) => __awaiter(void 0, void 0, void 0, function* () {
        yield client.query('listen foo');
        globals_1.expect.assertions(2);
        client.on('notification', (msg) => {
            (0, globals_1.expect)(msg.channel).toEqual('foo');
            (0, globals_1.expect)(msg.payload).toEqual('bar');
        });
        yield client.query('notify foo, \'bar\'');
    }));
    (0, helper_1.testWithClient)('Cursor', (client) => __awaiter(void 0, void 0, void 0, function* () {
        yield client.query('begin');
        yield client.query('declare foo cursor for select $1::int4', [1]);
        const result = yield client.query('fetch next from foo');
        (0, globals_1.expect)(result.names).toEqual(['int4']);
        (0, globals_1.expect)(result.rows).toEqual([[1]]);
    }));
    (0, helper_1.testWithClient)('Stream', (client) => __awaiter(void 0, void 0, void 0, function* () {
        globals_1.expect.assertions(2);
        const s = "abcdefghijklmnopqrstuvxyz".repeat(Math.pow(2, 17));
        const buffer = Buffer.from(s);
        const server = (0, net_1.createServer)((conn) => {
            let offset = 0;
            conn.on('data', (data) => {
                const s = data.toString();
                buffer.write(s, offset);
                offset += s.length;
            });
        });
        yield new Promise((resolve) => {
            server.listen(0, "localhost", 1, () => { resolve(undefined); });
        });
        (0, globals_1.expect)(server.listening).toBeTruthy();
        const address = server.address();
        const socket = new net_1.Socket();
        socket.connect(address.port);
        yield client.query({
            text: 'select upper($1)::bytea as col',
            streams: { col: socket }
        }, [Buffer.from(s)]);
        // At this point we're done really done streaming, and how can
        // we know when that happens?
        //
        // Probably, the query should return only when the callback
        // comes through.
        return new Promise((resolve) => {
            socket.on('close', () => {
                server.close(() => {
                    try {
                        (0, globals_1.expect)(buffer.toString()).toEqual(s.toUpperCase());
                    }
                    finally {
                        resolve(undefined);
                    }
                });
            });
            socket.end();
        });
    }));
    (0, helper_1.testWithClient)('Query errors become promise rejection', (client) => __awaiter(void 0, void 0, void 0, function* () {
        yield (0, globals_1.expect)(client.query('select foo')).rejects.toThrow(/foo/);
    }));
    const tests = [
        (client) => {
            return {
                query: client.query('select foo'),
                expectation: /foo/
            };
        },
        (client) => {
            return {
                query: client.query('select boo, $1 as bar', [0]),
                expectation: /boo/
            };
        },
        (client) => {
            return {
                query: client.query('select 1 as i'),
                expectation: { names: ['i'], rows: [[1]], status: 'SELECT 1' }
            };
        },
        (client) => {
            return {
                query: client.query('select 1 / $1 as j', [0]),
                expectation: /division by zero/
            };
        },
        (client) => {
            return {
                query: client.query('select $1::int as k', [2]),
                expectation: { names: ['k'], rows: [[2]], status: 'SELECT 1' }
            };
        },
        (client) => {
            return {
                query: client.query('select $1::internal as l', [""]),
                expectation: /2281/
            };
        },
        (client, seed) => {
            const random = makeRandomizer(seed);
            const alphabet = 'abcdefghijklmnopqrstuvwxyz';
            const columns = random(alphabet.length) || 1;
            const blocksize = random(71) || 1;
            const names = [];
            const row = [];
            let query = "select ";
            for (let i = 0; i < columns; i++) {
                const column = String.fromCharCode('a'.charCodeAt(0) + i);
                const string = alphabet.substring(0, i + 1).repeat(blocksize);
                names.push(column);
                row.push(string);
                if (i > 0)
                    query += ", ";
                query += `'${string}' as ${column}`;
            }
            return {
                query: client.query(query),
                expectation: { names: names, rows: [row], status: 'SELECT 1' }
            };
        },
        (client) => {
            return {
                query: client.prepare('select $1::int as i from badtable'),
                expectation: /badtable/
            };
        }
    ];
    function make(client, n, seed) {
        const p = tests[n](client, seed);
        const e = (0, globals_1.expect)(p.query);
        if (p.expectation instanceof RegExp) {
            return e.rejects.toThrow(p.expectation);
        }
        else {
            return e.resolves.toEqual(p.expectation);
        }
    }
    function makeTest(ns) {
        (0, helper_1.testWithClient)(`Pipeline combination query ${ns.join(';')}`, (client) => __awaiter(this, void 0, void 0, function* () {
            const promises = [];
            for (let i = 0; i < ns.length; i++) {
                const p = make(client, ns[i], 1);
                promises.push(p);
            }
            yield Promise.all(promises);
        }));
    }
    for (let i = 0; i < tests.length; i++) {
        makeTest([i]);
        for (let j = 0; j < tests.length; j++) {
            makeTest([i, j]);
        }
    }
    (0, helper_1.testWithClient)('Pipeline combination query (fuzzy)', (client) => __awaiter(void 0, void 0, void 0, function* () {
        const random = makeRandomizer(1);
        for (let i = 0; i < 5; i++) {
            let remaining = 500;
            while (remaining) {
                const count = Math.min(Math.max(random(remaining), 1), remaining / 2 >> 0) || 1;
                remaining -= count;
                const promises = [];
                for (let j = 0; j < count; j++) {
                    const n = random(tests.length);
                    const p = make(client, n, remaining);
                    promises.push(p);
                }
                yield Promise.all(promises);
            }
        }
    }));
    (0, helper_1.testWithClient)('Empty query', (client) => __awaiter(void 0, void 0, void 0, function* () {
        yield (0, globals_1.expect)(client.query('')).resolves.toEqual({ names: [], rows: [], status: null });
    }));
    (0, helper_1.testWithClient)('Unsupported type', (client) => __awaiter(void 0, void 0, void 0, function* () {
        const text = 'select $1::internal';
        yield (0, globals_1.expect)(client.query(text, [''])).rejects.toThrow(/2281/);
    }));
    (0, helper_1.testWithClient)('Prepare and execute (SELECT)', (client) => __awaiter(void 0, void 0, void 0, function* () {
        const stmt = yield client.prepare('select $1::int as i');
        yield (0, globals_1.expect)(stmt.execute([1])).resolves.toEqual({ names: ['i'], rows: [[1]], status: 'SELECT 1' });
        const result = yield stmt.execute([2]);
        (0, globals_1.expect)(result.rows).toEqual([[2]]);
        yield stmt.close();
    }));
    (0, helper_1.testWithClient)('Prepare and execute (SELECT)', (client) => __awaiter(void 0, void 0, void 0, function* () {
        const query = { text: 'select $1::int as i', transform: (s) => s.toUpperCase() };
        const stmt = yield client.prepare(query);
        yield (0, globals_1.expect)(stmt.execute([1])).resolves.toEqual({ names: ['I'], rows: [[1]], status: 'SELECT 1' });
        const result = yield stmt.execute([2]);
        (0, globals_1.expect)(result.rows).toEqual([[2]]);
        yield stmt.close();
    }));
    (0, helper_1.testWithClient)('Prepare and execute (INSERT)', (client) => __awaiter(void 0, void 0, void 0, function* () {
        yield client.query('create temporary table foo (bar int)');
        const stmt = yield client.prepare('insert into foo values ($1)');
        yield (0, globals_1.expect)(stmt.execute([1])).resolves.toEqual({ names: [], rows: [], status: 'INSERT 0 1' });
        const result = yield stmt.execute([2]);
        (0, globals_1.expect)(result.rows).toEqual([]);
        yield stmt.close();
    }));
    (0, helper_1.testWithClient)('Prepare and execute error', (client) => __awaiter(void 0, void 0, void 0, function* () {
        const stmt = client.prepare('select $1::int as i from badtable');
        yield (0, globals_1.expect)(stmt).rejects.toThrow(/badtable/);
    }));
    testSelect(0 /* TestQuery.PgType */, 1, false);
    testSelect(0 /* TestQuery.PgType */, 5, false);
    testSelect(0 /* TestQuery.PgType */, 1, true);
    testSelect(0 /* TestQuery.PgType */, 5, true);
    testSelect(1 /* TestQuery.Array */, 1, false);
    testSelect(1 /* TestQuery.Array */, 5, false);
    testSelect(1 /* TestQuery.Array */, 1, true);
    testSelect(1 /* TestQuery.Array */, 5, true);
});
//# sourceMappingURL=client.test.js.map
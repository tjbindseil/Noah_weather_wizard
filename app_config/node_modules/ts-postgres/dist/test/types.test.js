"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const globals_1 = require("@jest/globals");
const helper_1 = require("./helper");
const src_1 = require("../src");
const infinity = Number('Infinity');
function getComparisonQueryFor(dataType, expression) {
    switch (dataType) {
        case src_1.DataType.ArrayJson:
            return `select ($1)::jsonb[] <@ (${expression})::jsonb[]`;
        case src_1.DataType.Jsonb:
        case src_1.DataType.Json:
            return `select ($1)::jsonb <@ (${expression})::jsonb`;
        case src_1.DataType.Point:
            return `select $1 ~= ${expression}`;
        default:
            return `select $1 = ${expression}`;
    }
}
function testType(dataType, expression, expected, excludeTextMode = false, bigints) {
    const testParam = (format) => {
        (0, helper_1.testWithClient)('Param', (client) => __awaiter(this, void 0, void 0, function* () {
            globals_1.expect.assertions(3);
            const text = expected !== null
                ? getComparisonQueryFor(dataType, expression) + ' where $1 is not null'
                : 'select $1 is null';
            yield client.query({
                text,
                types: [dataType],
                format,
                bigints,
            }, [expected])
                .then((result) => {
                const rows = result.rows;
                (0, globals_1.expect)(rows.length).toEqual(1);
                (0, globals_1.expect)(rows[0].length).toEqual(1);
                (0, globals_1.expect)(rows[0][0]).toEqual(true);
            });
        }));
    };
    const testValue = (format) => {
        (0, helper_1.testWithClient)('Value', (client) => __awaiter(this, void 0, void 0, function* () {
            globals_1.expect.assertions(3);
            const text = 'select ' + expression;
            yield client.query({ text, format, bigints }, []).then((result) => {
                const rows = result.rows;
                (0, globals_1.expect)(rows.length).toEqual(1);
                (0, globals_1.expect)(rows[0].length).toEqual(1);
                (0, globals_1.expect)(rows[0][0]).toEqual(expected);
            });
        }));
    };
    (0, globals_1.describe)(`${expression} (${dataType}/binary)`, () => {
        testParam(src_1.DataFormat.Binary);
        testValue(src_1.DataFormat.Binary);
    });
    if (!excludeTextMode) {
        (0, globals_1.describe)(`${expression} (${dataType}/text)`, () => {
            testParam(src_1.DataFormat.Text);
            testValue(src_1.DataFormat.Text);
        });
    }
}
function utc_date(...rest) {
    return new Date(Date.UTC.apply(null, rest));
}
(0, globals_1.describe)('Types', () => {
    testType(src_1.DataType.Bool, 'true', true);
    testType(src_1.DataType.Bool, 'false', false);
    testType(src_1.DataType.Bpchar, '\'abc\'::char(3)', 'abc');
    testType(src_1.DataType.Bytea, '\'abc\'::bytea', Buffer.from('abc'));
    testType(src_1.DataType.Char, '\'a\'::char(1)', 'a');
    testType(src_1.DataType.Text, '\'a\'::text', 'a');
    testType(src_1.DataType.Int2, '1::int2', 1);
    testType(src_1.DataType.Int4, '1::int4', 1);
    testType(src_1.DataType.Int8, '1::int8', BigInt(1));
    testType(src_1.DataType.Int8, '1::int8', 1, undefined, false);
    testType(src_1.DataType.Float4, '1::float4', 1.0);
    testType(src_1.DataType.Float8, '1::float8', 1.0);
    testType(src_1.DataType.Oid, '1::oid', 1);
    testType(src_1.DataType.Date, '\'infinity\'::date', infinity);
    testType(src_1.DataType.Date, '\'-infinity\'::date', -infinity);
    testType(src_1.DataType.Date, '\'2000-01-01\'::date', utc_date(2000, 0, 1));
    testType(src_1.DataType.Date, '\'1999-12-31\'::date', utc_date(1999, 11, 31));
    testType(src_1.DataType.Date, '\'1998-12-31\'::date', utc_date(1998, 11, 31));
    testType(src_1.DataType.Date, '\'2001-12-31\'::date', utc_date(2001, 11, 31));
    testType(src_1.DataType.Timestamp, '\'infinity\'::timestamp', infinity);
    testType(src_1.DataType.Timestamp, '\'-infinity\'::timestamp', -infinity);
    testType(src_1.DataType.Timestamptz, '\'2000-01-01 00:00:00\'::timestamp at time zone \'utc\'', utc_date(2000, 0, 1, 0, 0, 0, 0));
    testType(src_1.DataType.Timestamptz, '\'1999-12-31 23:59:59.990\'::timestamp at time zone \'utc\'', utc_date(1999, 11, 31, 23, 59, 59, 990));
    testType(src_1.DataType.Timestamptz, '\'1970-01-01 00:00:00.000\'::timestamp at time zone \'utc\'', utc_date(1970, 0, 1, 0, 0, 0, 0));
    testType(src_1.DataType.Timestamptz, '\'2001-01-01 00:00:00\'::timestamp at time zone \'utc\'', utc_date(2001, 0, 1, 0, 0, 0, 0));
    testType(src_1.DataType.Timestamptz, '\'2000-01-01 00:00:00\'::timestamp at time zone \'utc\'', utc_date(2000, 0, 1, 0, 0, 0, 0));
    testType(src_1.DataType.Timestamptz, '\'1999-12-31 23:59:59.000\'::timestamp at time zone \'utc\'', utc_date(1999, 11, 31, 23, 59, 59, 0));
    testType(src_1.DataType.Timestamptz, '\'1999-12-31 23:59:59Z\'::timestamptz', utc_date(1999, 11, 31, 23, 59, 59));
    testType(src_1.DataType.Timestamptz, '\'1970-01-01 00:00:00Z\'::timestamptz', utc_date(1970, 0, 1, 0, 0, 0));
    testType(src_1.DataType.Timestamptz, '\'1893-03-31 22:46:55+00:53:27\'::timestamptz', utc_date(1893, 2, 31, 21, 53, 28));
    testType(src_1.DataType.Date, '\'0002-12-31 BC\'::date', utc_date(-1, 11, 31));
    testType(src_1.DataType.ArrayTimestamptz, 'ARRAY[null,\'1999-12-31 23:59:59Z\']::timestamptz[]', [null, utc_date(1999, 11, 31, 23, 59, 59)]);
    testType(src_1.DataType.ArrayTimestamptz, 'ARRAY[ARRAY[null],ARRAY[\'1999-12-31 23:59:59Z\']]::timestamptz[][]', [[null], [utc_date(1999, 11, 31, 23, 59, 59)]]);
    testType(src_1.DataType.Point, '\'(1,2)\'::Point', { x: 1, y: 2 }, true);
    testType(src_1.DataType.Uuid, '\'123e4567-e89b-12d3-a456-426655440000\'::uuid', '123e4567-e89b-12d3-a456-426655440000');
    testType(src_1.DataType.ArrayUuid, 'ARRAY[\'123e4567-e89b-12d3-a456-426655440000\'::uuid]', ['123e4567-e89b-12d3-a456-426655440000']);
    testType(src_1.DataType.ArrayInt2, '\'{1,2,3}\'::int2[3]', [1, 2, 3]);
    testType(src_1.DataType.ArrayInt4, '\'{1,2,3}\'::int4[3]', [1, 2, 3]);
    testType(src_1.DataType.ArrayInt4, '\'{42}\'::int4[3]', [42]);
    testType(src_1.DataType.ArrayInt4, '\'{{{1, 2}, {3, 4}}, {{5, 6}, {7, 8}}}\'::int4[]', [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]);
    testType(src_1.DataType.ArrayInt8, '\'{1,2,3}\'::int8[3]', [BigInt(1), BigInt(2), BigInt(3)]);
    testType(src_1.DataType.ArrayInt8, '\'{1,2,3}\'::int8[3]', [1, 2, 3], undefined, false);
    testType(src_1.DataType.ArrayFloat4, '\'{1.0, 2.0, 3.0}\'::float4[3]', [1.0, 2.0, 3.0]);
    testType(src_1.DataType.ArrayFloat4, '\'{1.125,2.250,3.375}\'::float4[3]', [1.125, 2.250, 3.375]);
    testType(src_1.DataType.ArrayFloat4, '\'{16777217.0}\'::float4[1]', [Math.pow(2, 24)]);
    testType(src_1.DataType.ArrayFloat8, '\'{16777217.0}\'::float8[1]', [Math.pow(2, 24) + 1]);
    testType(src_1.DataType.ArrayVarchar, '\'{abc}\'::varchar[]', ['abc']);
    testType(src_1.DataType.ArrayVarchar, '\'{"\\"abc\\""}\'::varchar[]', ['"abc"']);
    testType(src_1.DataType.ArrayVarchar, '\'{"Ŝќ⽜"}\'::varchar[]', ['Ŝќ⽜']);
    testType(src_1.DataType.ArrayBpchar, '\'{a}\'::bpchar[]', ['a']);
    testType(src_1.DataType.ArrayBytea, '\'{abc}\'::bytea[]', [Buffer.from('abc')]);
    testType(src_1.DataType.ArrayText, '\'{a}\'::text[]', ['a']);
    testType(src_1.DataType.ArrayText, '\'{"a,"}\'::text[]', ['a,']);
    testType(src_1.DataType.ArrayText, 'ARRAY[null]::text[]', [null]);
    testType(src_1.DataType.ArrayText, `ARRAY['a', null, 'b', null]::text[]`, ['a', null, 'b', null]);
    testType(src_1.DataType.ArrayText, `ARRAY[ARRAY['a',null,'b'],ARRAY[null, 'c', null]]::text[][]`, [['a', null, 'b'], [null, 'c', null]]);
    testType(src_1.DataType.ArrayDate, '\'{2000-01-01}\'::date[]', [utc_date(2000, 0, 1)]);
    testType(src_1.DataType.ArrayTimestamp, 'ARRAY[\'infinity\'::timestamp]', [infinity]);
    testType(src_1.DataType.ArrayTimestamptz, 'ARRAY[\'1999-12-31 23:59:59\'::timestamp at time zone \'utc\']', [utc_date(1999, 11, 31, 23, 59, 59)]);
    testType(src_1.DataType.ArrayTimestamptz, '\'{1999-12-31 23:59:59Z}\'::timestamptz[]', [utc_date(1999, 11, 31, 23, 59, 59)]);
    testType(src_1.DataType.Json, '\'{"foo": "bar"}\'::json', { 'foo': 'bar' });
    testType(src_1.DataType.Jsonb, '\'{"foo": "bar"}\'::jsonb', { 'foo': 'bar' });
    testType(src_1.DataType.ArrayJsonb, 'ARRAY[\'{"foo": "bar"}\'::jsonb, \'{"bar": "baz"}\'::jsonb]', [{ 'foo': 'bar' }, { 'bar': 'baz' }]);
    testType(src_1.DataType.ArrayJson, 'ARRAY[\'{"foo": "bar"}\'::json]', [{ 'foo': 'bar' }]);
    // Test nulls
    testType(src_1.DataType.Bool, 'null::bool', null);
    testType(src_1.DataType.Uuid, 'null::uuid', null);
    testType(src_1.DataType.Text, 'null::text', null);
    testType(src_1.DataType.ArrayText, 'null::text[]', null);
    testType(src_1.DataType.ArrayText, 'null::text[][]', null);
    testType(src_1.DataType.ArrayTimestamptz, 'null::timestamptz', null);
    testType(src_1.DataType.ArrayTimestamptz, 'null::timestamptz[]', null);
    testType(src_1.DataType.ArrayTimestamptz, 'null::timestamptz[][]', null);
});
//# sourceMappingURL=types.test.js.map
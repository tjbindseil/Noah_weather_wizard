/// <reference types="node" />
/// <reference types="node" />
import { Writable } from 'stream';
import { postgresqlErrorCodes } from './errors';
import { Query } from './query';
import { ConnectionOptions } from 'tls';
import { ResultIterator, ResultRecord } from './result';
import { ClientConnectionDefaults, ClientConnectionOptions, DatabaseError, ErrorLevel, TransactionStatus } from './protocol';
import { DataFormat, DataType, ValueTypeReader } from './types';
export interface ConnectionInfo {
    encrypted: boolean;
    parameters: ReadonlyMap<string, string>;
}
export interface ClientNotice extends DatabaseError {
    level: ErrorLevel;
    code: keyof typeof postgresqlErrorCodes;
    message: string;
}
export interface DataTypeError {
    dataType: DataType;
    value: any;
}
export declare enum SSLMode {
    Disable = "disable",
    Prefer = "prefer",
    Require = "require"
}
export interface SSL {
    mode: (SSLMode.Prefer | SSLMode.Require);
    options?: ConnectionOptions;
}
export interface Configuration extends Partial<ClientConnectionDefaults & ClientConnectionOptions> {
    user?: string;
    database?: string;
    host?: string;
    port?: number;
    password?: string;
    types?: Map<DataType, ValueTypeReader>;
    bigints?: boolean;
    keepAlive?: boolean;
    preparedStatementPrefix?: string;
    connectionTimeout?: number;
    ssl?: (SSLMode.Disable | SSL);
}
export interface Notification {
    processId: number;
    channel: string;
    payload?: string;
}
export interface PreparedStatement<T = ResultRecord> {
    close: (portal?: string) => Promise<void>;
    execute: (values?: any[], portal?: string, format?: DataFormat | DataFormat[], streams?: Record<string, Writable>) => ResultIterator<T>;
}
export type Callback<T> = (data: T) => void;
/** A database client, opening a single connection to the database.
 *
 * @remarks
 * You must open the connection using {@link connect}, otherwise no query will be processed.
 */
export declare class Client {
    readonly config: Configuration;
    private readonly events;
    private ending;
    private connected;
    private connecting;
    private error;
    private readonly encoding;
    private readonly writer;
    private readonly clientNonce;
    private serverSignature;
    private expect;
    private stream;
    private mustDrain;
    private activeRow;
    private bindQueue;
    private closeHandlerQueue;
    private cleanupQueue;
    private errorHandlerQueue;
    private preFlightQueue;
    private rowDescriptionQueue;
    private parameterDescriptionQueue;
    private nextPreparedStatementId;
    private activeDataHandlerInfo;
    private readonly parameters;
    closed: boolean;
    processId: number | null;
    secretKey: number | null;
    transactionStatus: TransactionStatus | null;
    /**
    * @param config - An optional configuration object, comprised of connection details
    *     and client configuration. Most of the connection details can also be specified
    *     using environment variables, see {@link Environment}.
    */
    constructor(config?: Configuration);
    private startup;
    private receive;
    /** Connect to the database.
     *
     * @remarks
     * Don't forget to close the connection using {@link end} before exiting.
     *
     * @returns The connection information.
     */
    connect(): Promise<ConnectionInfo>;
    /** End the database connection.
     *
     */
    end(): Promise<void>;
    on(event: 'notification', callback: Callback<Notification>): void;
    on(event: 'error', callback: Callback<DatabaseError>): void;
    on(event: 'notice', callback: Callback<ClientNotice>): void;
    /** Prepare a statement for later execution.
     *
     * @returns A prepared statement object.
     */
    prepare<T = ResultRecord>(text: Query | string): Promise<PreparedStatement<T>>;
    /**
     * Send a query to the database.
     *
     * The query string is given as the first argument, or pass a {@link Query}
     * object which provides more control.
     *
     * @param text - The query string, or pass a {@link Query}
     *     object which provides more control (including streaming values into a socket).
     * @param values - The query parameters, corresponding to $1, $2, etc.
     * @returns A promise for the query results.
     */
    query<T = ResultRecord>(text: Query | string, values?: any[]): ResultIterator<T>;
    private bindAndExecute;
    private handleError;
    private send;
    private sendUsing;
    private parseError;
    private handle;
}

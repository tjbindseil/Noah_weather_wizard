"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = exports.SSLMode = void 0;
const crypto_1 = require("crypto");
const os_1 = require("os");
const net_1 = require("net");
const ts_typed_events_1 = require("ts-typed-events");
const defaults = require("./defaults");
const logger = require("./logging");
const queue_1 = require("./queue");
const tls_1 = require("tls");
const result_1 = require("./result");
const protocol_1 = require("./protocol");
const types_1 = require("./types");
const utils_1 = require("./utils");
var SSLMode;
(function (SSLMode) {
    SSLMode["Disable"] = "disable";
    SSLMode["Prefer"] = "prefer";
    SSLMode["Require"] = "require";
})(SSLMode = exports.SSLMode || (exports.SSLMode = {}));
/** A database client, opening a single connection to the database.
 *
 * @remarks
 * You must open the connection using {@link connect}, otherwise no query will be processed.
 */
class Client {
    /**
    * @param config - An optional configuration object, comprised of connection details
    *     and client configuration. Most of the connection details can also be specified
    *     using environment variables, see {@link Environment}.
    */
    constructor(config = {}) {
        this.config = config;
        this.events = {
            connect: new ts_typed_events_1.Event(),
            end: new ts_typed_events_1.Event(),
            error: new ts_typed_events_1.Event(),
            notice: new ts_typed_events_1.Event(),
            notification: new ts_typed_events_1.Event()
        };
        this.ending = false;
        this.connected = false;
        this.connecting = false;
        this.error = false;
        this.clientNonce = (0, crypto_1.randomBytes)(18).toString('base64');
        this.serverSignature = null;
        this.expect = 5;
        this.stream = new net_1.Socket();
        this.mustDrain = false;
        this.activeRow = null;
        this.bindQueue = new queue_1.Queue();
        this.closeHandlerQueue = new queue_1.Queue();
        this.cleanupQueue = new queue_1.Queue();
        this.errorHandlerQueue = new queue_1.Queue();
        this.preFlightQueue = new queue_1.Queue();
        this.rowDescriptionQueue = new queue_1.Queue();
        this.parameterDescriptionQueue = new queue_1.Queue();
        this.nextPreparedStatementId = 0;
        this.activeDataHandlerInfo = null;
        this.parameters = new Map();
        this.closed = true;
        this.processId = null;
        this.secretKey = null;
        this.transactionStatus = null;
        this.encoding = config.clientEncoding || defaults.clientEncoding || 'utf-8';
        this.writer = new protocol_1.Writer(this.encoding);
        this.stream.on('close', () => {
            this.closed = true;
            this.events.end.emit(null);
        });
        this.stream.on('connect', () => {
            const keepAlive = (typeof this.config.keepAlive === 'undefined') ?
                this.config.keepAlive : true;
            if (keepAlive) {
                this.stream.setKeepAlive(true);
            }
            this.closed = false;
            this.startup();
        });
        /* istanbul ignore next */
        this.stream.on('error', (error) => {
            if (this.connecting) {
                this.events.connect.emit(error);
            }
            else {
                // Don't raise ECONNRESET errors - they can & should be
                // ignored during disconnect.
                if (this.ending && error.errno ===
                    os_1.constants.errno.ECONNRESET)
                    return;
                this.events.end.emit(error);
            }
        });
        this.stream.on('finish', () => {
            this.connected = false;
        });
    }
    startup() {
        var _a;
        const writer = new protocol_1.Writer(this.encoding);
        if (defaults.sslMode && Object.values(SSLMode).indexOf(defaults.sslMode) < 0) {
            throw new Error("Invalid SSL mode: " + defaults.sslMode);
        }
        const ssl = ((_a = this.config.ssl) !== null && _a !== void 0 ? _a : (defaults.sslMode || SSLMode.Disable) === SSLMode.Disable)
            ? SSLMode.Disable
            : ({ mode: SSLMode.Prefer, options: undefined });
        const settings = {
            user: this.config.user || defaults.user,
            database: this.config.database || defaults.database,
            clientMinMessages: this.config.clientMinMessages,
            defaultTableAccessMethod: this.config.defaultTableAccessMethod,
            defaultTablespace: this.config.defaultTablespace,
            defaultTransactionIsolation: this.config.defaultTransactionIsolation,
            extraFloatDigits: this.config.extraFloatDigits,
            idleInTransactionSessionTimeout: this.config.idleInTransactionSessionTimeout,
            idleSessionTimeout: this.config.idleSessionTimeout,
            lockTimeout: this.config.lockTimeout,
            searchPath: this.config.searchPath,
            statementTimeout: this.config.statementTimeout,
        };
        if (ssl !== SSLMode.Disable) {
            writer.startupSSL();
            const abort = (error) => {
                if (!this.handleError(error)) {
                    throw new Error("Internal error occurred while establishing connection");
                }
                this.events.connect.emit(error);
                this.end();
            };
            const startup = (stream) => {
                if (stream)
                    this.stream = stream;
                writer.startup(settings);
                this.receive();
                this.sendUsing(writer);
            };
            this.stream.once('data', (buffer) => {
                var _a;
                const code = buffer.readInt8(0);
                switch (code) {
                    // Server supports SSL connections, continue.
                    case 83 /* SSLResponseCode.Supported */:
                        break;
                    // Server does not support SSL connections.
                    case 78 /* SSLResponseCode.NotSupported */:
                        if (ssl.mode === SSLMode.Require) {
                            abort(new Error('Server does not support SSL connections'));
                        }
                        else {
                            startup();
                        }
                        return;
                    // Any other response byte, including 'E'
                    // (ErrorResponse) indicating a server error.
                    default:
                        abort(new Error('Error establishing an SSL connection'));
                        return;
                }
                const context = ssl.options ?
                    (0, tls_1.createSecureContext)(ssl.options) :
                    undefined;
                const options = Object.assign({ socket: this.stream, secureContext: context }, ((_a = ssl.options) !== null && _a !== void 0 ? _a : {}));
                const stream = (0, tls_1.connect)(options, () => startup(stream));
                stream.on('error', (error) => {
                    abort(error);
                });
            });
        }
        else {
            writer.startup(settings);
            this.receive();
        }
        this.sendUsing(writer);
    }
    receive() {
        let buffer = null;
        let offset = 0;
        let remaining = 0;
        this.stream.on('data', (newBuffer) => {
            const length = newBuffer.length;
            const size = length + remaining;
            if (buffer && remaining) {
                const free = buffer.length - offset - remaining;
                let tail = offset + remaining;
                if (free < length) {
                    const tempBuf = Buffer.allocUnsafe(size);
                    buffer.copy(tempBuf, 0, offset, tail);
                    offset = 0;
                    buffer = tempBuf;
                    tail = remaining;
                }
                newBuffer.copy(buffer, tail, 0, length);
            }
            else {
                buffer = newBuffer;
                offset = 0;
            }
            try {
                const read = this.handle(buffer, offset, size);
                offset += read;
                remaining = size - read;
            }
            catch (error) {
                logger.warn(error);
                if (this.connecting) {
                    this.events.connect.emit(error);
                }
                else {
                    try {
                        while (this.handleError(error)) {
                            logger.info("Cancelled query due to an internal error");
                        }
                    }
                    catch (error) {
                        logger.error("Internal error occurred while cleaning up query stack");
                    }
                }
                this.stream.destroy();
            }
        });
        this.stream.on('drain', () => {
            this.mustDrain = false;
            this.writer.flush();
            this.send();
        });
    }
    /** Connect to the database.
     *
     * @remarks
     * Don't forget to close the connection using {@link end} before exiting.
     *
     * @returns The connection information.
     */
    connect() {
        if (this.connecting) {
            throw new Error('Already connecting');
        }
        if (this.error) {
            throw new Error('Can\'t connect in error state');
        }
        this.connecting = true;
        const timeout = this.config.connectionTimeout || defaults.connectionTimeout;
        let p = this.events.connect.once().then((error) => {
            if (error) {
                this.connecting = false;
                this.stream.destroy();
                throw error;
            }
            return {
                encrypted: this.stream instanceof tls_1.TLSSocket,
                parameters: this.parameters,
            };
        });
        const port = this.config.port || defaults.port;
        const host = this.config.host || defaults.host;
        if (host.indexOf('/') === 0) {
            this.stream.connect(host + '/.s.PGSQL.' + port);
        }
        else {
            this.stream.connect(port, host);
        }
        if (typeof timeout !== "undefined") {
            p = Promise.race([
                p,
                new Promise((_, reject) => setTimeout(() => reject(new Error(`Timeout after ${timeout} ms`)), timeout)),
            ]);
        }
        return p;
    }
    /** End the database connection.
     *
     */
    end() {
        if (this.ending) {
            throw new Error('Already ending');
        }
        if (this.closed) {
            throw new Error('Connection already closed');
        }
        if (this.stream.destroyed) {
            throw new Error('Connection unexpectedly destroyed');
        }
        this.ending = true;
        if (this.connected) {
            this.writer.end();
            this.send();
            this.stream.end();
            this.mustDrain = false;
        }
        else {
            this.stream.destroy();
        }
        return new Promise((resolve, reject) => this.events.end.once().then(value => {
            if (value === null)
                resolve();
            reject(value);
        }));
    }
    on(event, callback) {
        switch (event) {
            case 'error': {
                this.events.error.on(callback);
                break;
            }
            case 'notice': {
                this.events.notice.on(callback);
                break;
            }
            case 'notification': {
                this.events.notification.on(callback);
                break;
            }
        }
    }
    /** Prepare a statement for later execution.
     *
     * @returns A prepared statement object.
     */
    prepare(text) {
        const query = typeof text === 'string' ? { text } : text;
        const providedNameOrGenerated = query.name || ((this.config.preparedStatementPrefix ||
            defaults.preparedStatementPrefix) + (this.nextPreparedStatementId++));
        return new Promise((resolve, reject) => {
            const errorHandler = (error) => reject(error);
            this.errorHandlerQueue.push(errorHandler);
            this.writer.parse(providedNameOrGenerated, query.text, query.types || []);
            this.writer.describe(providedNameOrGenerated, 'S');
            this.preFlightQueue.push({
                descriptionHandler: (description) => {
                    const types = this.parameterDescriptionQueue.shift();
                    this.cleanupQueue.expect(3 /* Cleanup.ParameterDescription */);
                    resolve({
                        close: () => {
                            return new Promise((resolve) => {
                                this.writer.close(providedNameOrGenerated, 'S');
                                this.closeHandlerQueue.push(resolve);
                                this.cleanupQueue.push(1 /* Cleanup.Close */);
                                this.writer.flush();
                                this.send();
                            });
                        },
                        execute: (values, portal, format, streams) => {
                            var _a, _b;
                            const result = (0, result_1.makeResult)(query === null || query === void 0 ? void 0 : query.transform);
                            result.nameHandler(description.names);
                            const info = {
                                handler: {
                                    callback: result.dataHandler,
                                    streams: streams || {},
                                    bigints: (_b = (_a = query.bigints) !== null && _a !== void 0 ? _a : this.config.bigints) !== null && _b !== void 0 ? _b : true,
                                },
                                description: description,
                            };
                            this.bindAndExecute(info, {
                                name: providedNameOrGenerated,
                                portal: portal || query.portal || '',
                                format: format || query.format || types_1.DataFormat.Binary,
                                values: values || [],
                                close: false
                            }, types || query.types);
                            return result.iterator;
                        }
                    });
                },
                dataHandler: null,
                bind: null
            });
            this.writer.sync();
            this.cleanupQueue.push(4 /* Cleanup.PreFlight */);
            this.cleanupQueue.push(2 /* Cleanup.ErrorHandler */);
            this.send();
        });
    }
    /**
     * Send a query to the database.
     *
     * The query string is given as the first argument, or pass a {@link Query}
     * object which provides more control.
     *
     * @param text - The query string, or pass a {@link Query}
     *     object which provides more control (including streaming values into a socket).
     * @param values - The query parameters, corresponding to $1, $2, etc.
     * @returns A promise for the query results.
     */
    query(text, values) {
        var _a, _b;
        const query = typeof text === 'string' ? { text } : text;
        if (this.closed && !this.connecting) {
            throw new Error('Connection is closed.');
        }
        const format = query === null || query === void 0 ? void 0 : query.format;
        const types = query === null || query === void 0 ? void 0 : query.types;
        const streams = query === null || query === void 0 ? void 0 : query.streams;
        const portal = (query === null || query === void 0 ? void 0 : query.portal) || '';
        const result = (0, result_1.makeResult)(query === null || query === void 0 ? void 0 : query.transform);
        const descriptionHandler = (description) => {
            result.nameHandler(description.names);
        };
        const dataHandler = {
            callback: result.dataHandler,
            streams: streams || {},
            bigints: (_b = (_a = query.bigints) !== null && _a !== void 0 ? _a : this.config.bigints) !== null && _b !== void 0 ? _b : true,
        };
        if (values && values.length) {
            const name = (query === null || query === void 0 ? void 0 : query.name) || ((this.config.preparedStatementPrefix ||
                defaults.preparedStatementPrefix) + (this.nextPreparedStatementId++));
            this.writer.parse(name, query.text, types || []);
            this.writer.describe(name, 'S');
            this.preFlightQueue.push({
                descriptionHandler: descriptionHandler,
                dataHandler: dataHandler,
                bind: {
                    name: name,
                    portal: portal,
                    format: format || types_1.DataFormat.Binary,
                    values: values,
                    close: true
                }
            });
            this.cleanupQueue.push(4 /* Cleanup.PreFlight */);
        }
        else {
            const name = query.name || '';
            this.writer.parse(name, query.text);
            this.writer.bind(name, portal);
            this.bindQueue.push(null);
            this.writer.describe(portal, 'P');
            this.preFlightQueue.push({
                descriptionHandler: descriptionHandler,
                dataHandler: dataHandler,
                bind: null
            });
            this.writer.execute(portal);
            this.writer.close(name, 'S');
            this.cleanupQueue.push(0 /* Cleanup.Bind */);
            this.cleanupQueue.push(4 /* Cleanup.PreFlight */);
            this.closeHandlerQueue.push(null);
            this.cleanupQueue.push(1 /* Cleanup.Close */);
        }
        const stack = new Error().stack;
        this.errorHandlerQueue.push((error) => {
            if (stack !== undefined)
                error.stack = stack.replace(/(?<=^Error: )\n/, error.toString() + "\n");
            result.dataHandler(error);
        });
        this.cleanupQueue.push(2 /* Cleanup.ErrorHandler */);
        this.writer.sync();
        this.send();
        return result.iterator;
    }
    bindAndExecute(info, bind, types) {
        try {
            this.writer.bind(bind.name, bind.portal, bind.format, bind.values, types);
        }
        catch (error) {
            info.handler.callback(error);
            return;
        }
        this.bindQueue.push(info);
        this.writer.execute(bind.portal);
        this.cleanupQueue.push(0 /* Cleanup.Bind */);
        if (bind.close) {
            this.writer.close(bind.name, 'S');
            this.closeHandlerQueue.push(null);
            this.cleanupQueue.push(1 /* Cleanup.Close */);
        }
        this.writer.sync();
        this.errorHandlerQueue.push((error) => { info.handler.callback(error); });
        this.cleanupQueue.push(2 /* Cleanup.ErrorHandler */);
        this.send();
    }
    handleError(error) {
        while (true) {
            switch (this.cleanupQueue.shiftMaybe()) {
                case undefined: return false;
                case 0 /* Cleanup.Bind */: {
                    this.bindQueue.shift();
                    break;
                }
                case 1 /* Cleanup.Close */: {
                    this.closeHandlerQueue.shift();
                    break;
                }
                case 2 /* Cleanup.ErrorHandler */: {
                    const handler = this.errorHandlerQueue.shift();
                    handler(error);
                    this.error = true;
                    return true;
                }
                case 3 /* Cleanup.ParameterDescription */: {
                    // This does not seem to ever happen!
                    this.parameterDescriptionQueue.shift();
                    break;
                }
                case 4 /* Cleanup.PreFlight */: {
                    this.preFlightQueue.shift();
                    break;
                }
                case 5 /* Cleanup.RowDescription */: {
                    this.rowDescriptionQueue.shift();
                    break;
                }
            }
        }
    }
    send() {
        if (this.mustDrain || !this.connected)
            return;
        this.sendUsing(this.writer);
    }
    sendUsing(writer) {
        if (this.ending)
            return;
        if (!this.stream.writable)
            throw new Error('Stream not writable');
        const full = writer.send(this.stream);
        if (full !== undefined) {
            this.mustDrain = !full;
        }
    }
    parseError(buffer) {
        let level = null;
        let code = null;
        let message = null;
        let details = null;
        const length = buffer.length;
        let offset = 0;
        while (offset < length) {
            const next = buffer.indexOf(0, offset);
            if (next < 0)
                break;
            const value = buffer.subarray(offset + 1, next).toString();
            switch (buffer[offset]) {
                case 0x53: {
                    if (level === null) {
                        level = value;
                    }
                    break;
                }
                case 0x56: {
                    level = value;
                    break;
                }
                case 0x43: {
                    code = value;
                    break;
                }
                case 0x44: {
                    details = value;
                    break;
                }
                case 0x4d: {
                    message = value;
                    break;
                }
                default:
                    break;
            }
            offset = next + 1;
        }
        if (level && code && message) {
            return new protocol_1.DatabaseError(level, code, details ? `${message}: ${details}` : message);
        }
        throw new Error('Unable to parse error message.');
    }
    handle(buffer, offset, size) {
        let read = 0;
        while (size >= this.expect + read) {
            let frame = offset + read;
            let mtype = buffer.readInt8(frame);
            // Fast path: retrieve data rows.
            if (mtype === 68 /* Message.RowData */) {
                const info = this.activeDataHandlerInfo;
                if (!info) {
                    throw new Error('No active data handler');
                }
                if (!info.description) {
                    throw new Error('No result type information');
                }
                const { handler: { callback, streams, bigints, }, description: { columns, names, } } = info;
                let row = this.activeRow;
                const types = this.config.types;
                const encoding = this.encoding;
                const hasStreams = Object.keys(streams).length > 0;
                const mappedStreams = hasStreams ? names.map(name => streams[name]) : undefined;
                while (true) {
                    mtype = buffer.readInt8(frame);
                    if (mtype !== 68 /* Message.RowData */)
                        break;
                    const bytes = buffer.readInt32BE(frame + 1) + 1;
                    const start = frame + 5;
                    if (size < 11 + read) {
                        this.expect = 7;
                        this.activeRow = row;
                        return read;
                    }
                    if (row === null) {
                        const count = buffer.readInt16BE(start);
                        row = new Array(count);
                    }
                    const startRowData = start + 2;
                    const reader = new protocol_1.Reader(buffer, startRowData, bytes + read);
                    const end = reader.readRowData(row, columns, encoding, bigints, types, mappedStreams);
                    const remaining = bytes + read - size;
                    if (remaining <= 0) {
                        callback(row);
                        row = null;
                    }
                    else {
                        const offset = startRowData + end;
                        buffer.writeInt8(mtype, offset - 7);
                        buffer.writeInt32BE(bytes - end - 1, offset - 6);
                        buffer.writeInt16BE(row.length, offset - 2);
                        this.expect = 12;
                        this.activeRow = row;
                        return read + end;
                    }
                    // Keep track of how much data we've consumed.
                    frame += bytes;
                    // If the next message header doesn't fit, we
                    // break out and wait for more data to arrive.
                    if (size < frame + 5) {
                        this.activeRow = row;
                        this.expect = 5;
                        return read;
                    }
                    read += bytes;
                }
                this.activeRow = null;
            }
            const bytes = buffer.readInt32BE(frame + 1) + 1;
            const length = bytes - 5;
            if (size < bytes + read) {
                this.expect = bytes;
                break;
            }
            this.expect = 5;
            read += bytes;
            // This is the start offset of the message data.
            const start = frame + 5;
            switch (mtype) {
                case 82 /* Message.Authentication */: {
                    const writer = new protocol_1.Writer(this.encoding);
                    const code = buffer.readInt32BE(start);
                    outer: 
                    /* istanbul ignore next */
                    switch (code) {
                        case 0: {
                            process.nextTick(() => {
                                this.events.connect.emit(null);
                            });
                            break;
                        }
                        case 3: {
                            const s = this.config.password || defaults.password || '';
                            writer.password(s);
                            break;
                        }
                        case 5: {
                            const { user = '', password = '' } = this.config;
                            const salt = buffer.subarray(start + 4, start + 8);
                            const shadow = (0, utils_1.md5)(`${password || defaults.password}` +
                                `${user || defaults.user}`);
                            writer.password(`md5${(0, utils_1.md5)(shadow, salt)}`);
                            break;
                        }
                        case 10: {
                            const reader = new protocol_1.Reader(buffer, start + 4);
                            const mechanisms = [];
                            while (true) {
                                const mechanism = reader.readCString(this.encoding);
                                if (mechanism.length === 0)
                                    break;
                                if (writer.saslInitialResponse(mechanism, this.clientNonce))
                                    break outer;
                                mechanisms.push(mechanism);
                            }
                            throw new Error(`SASL authentication unsupported (mechanisms: ${mechanisms.join(', ')})`);
                        }
                        case 11: {
                            const data = buffer.subarray(start + 4, start + length).toString("utf8");
                            const password = this.config.password || defaults.password || '';
                            this.serverSignature = writer.saslResponse(data, password, this.clientNonce);
                            break;
                        }
                        case 12: {
                            const data = buffer.subarray(start + 4, start + length).toString("utf8");
                            if (!this.serverSignature)
                                throw new Error('Server signature missing');
                            writer.saslFinal(data, this.serverSignature);
                            break;
                        }
                        default:
                            throw new Error(`Unsupported authentication scheme: ${code}`);
                    }
                    this.sendUsing(writer);
                    break;
                }
                case 75 /* Message.BackendKeyData */: {
                    this.processId = buffer.readInt32BE(start);
                    this.secretKey = buffer.readInt32BE(start + 4);
                    break;
                }
                case 50 /* Message.BindComplete */: {
                    const info = this.bindQueue.shift();
                    this.cleanupQueue.expect(0 /* Cleanup.Bind */);
                    if (info) {
                        this.activeDataHandlerInfo = info;
                    }
                    break;
                }
                case 110 /* Message.NoData */: {
                    const preflight = this.preFlightQueue.shift();
                    if (preflight.dataHandler) {
                        const info = {
                            handler: preflight.dataHandler,
                            description: null,
                        };
                        if (preflight.bind) {
                            this.cleanupQueue.expect(3 /* Cleanup.ParameterDescription */);
                            this.bindAndExecute(info, preflight.bind, this.parameterDescriptionQueue.shift());
                        }
                        else {
                            this.activeDataHandlerInfo = info;
                        }
                    }
                    else {
                        preflight.descriptionHandler({
                            columns: new Uint32Array(0),
                            names: [],
                        });
                    }
                    this.cleanupQueue.expect(4 /* Cleanup.PreFlight */);
                    break;
                }
                case 73 /* Message.EmptyQueryResponse */:
                case 67 /* Message.CommandComplete */: {
                    const info = this.activeDataHandlerInfo;
                    if (info) {
                        const status = buffer.subarray(start, start + length - 1).toString();
                        info.handler.callback(status || null);
                        this.activeDataHandlerInfo = null;
                    }
                    break;
                }
                case 51 /* Message.CloseComplete */: {
                    const handler = this.closeHandlerQueue.shift();
                    this.cleanupQueue.expect(1 /* Cleanup.Close */);
                    if (handler) {
                        handler();
                    }
                    break;
                }
                case 69 /* Message.ErrorResponse */: {
                    const error = this.parseError(buffer.subarray(start, start + length));
                    if (this.connecting)
                        throw error;
                    this.events.error.emit(error);
                    loop: if (!this.handleError(error)) {
                        throw new Error("Internal error occurred while processing database error");
                    }
                    break;
                }
                case 78 /* Message.Notice */: {
                    const notice = this.parseError(buffer.subarray(start, start + length));
                    this.events.notice.emit(notice);
                    break;
                }
                case 65 /* Message.NotificationResponse */: {
                    const reader = new protocol_1.Reader(buffer, start);
                    const processId = reader.readInt32BE();
                    const channel = reader.readCString(this.encoding);
                    const payload = reader.readCString(this.encoding);
                    this.events.notification.emit({
                        processId: processId,
                        channel: channel,
                        payload: payload
                    });
                    break;
                }
                case 49 /* Message.ParseComplete */: {
                    break;
                }
                case 116 /* Message.ParameterDescription */: {
                    const length = buffer.readInt16BE(start);
                    const types = new Array(length);
                    for (let i = 0; i < length; i++) {
                        const offset = start + 2 + i * 4;
                        const dataType = buffer.readInt32BE(offset);
                        types[i] = dataType;
                    }
                    this.cleanupQueue.unshift(3 /* Cleanup.ParameterDescription */);
                    this.parameterDescriptionQueue.push(types);
                    break;
                }
                case 83 /* Message.ParameterStatus */: {
                    const reader = new protocol_1.Reader(buffer, start);
                    const name = reader.readCString(this.encoding);
                    const value = reader.readCString(this.encoding);
                    this.parameters.set(name, value);
                    break;
                }
                case 90 /* Message.ReadyForQuery */: {
                    if (this.error) {
                        this.error = false;
                    }
                    else if (this.connected) {
                        this.errorHandlerQueue.shift();
                        this.cleanupQueue.expect(2 /* Cleanup.ErrorHandler */);
                    }
                    else {
                        this.connecting = false;
                        this.connected = true;
                    }
                    const status = buffer.readInt8(start);
                    this.transactionStatus = status;
                    this.send();
                    break;
                }
                case 84 /* Message.RowDescription */: {
                    const preflight = this.preFlightQueue.shift();
                    const reader = new protocol_1.Reader(buffer, start);
                    const description = reader.readRowDescription(this.config.types);
                    preflight.descriptionHandler(description);
                    if (preflight.dataHandler) {
                        const info = {
                            handler: preflight.dataHandler,
                            description: description,
                        };
                        if (preflight.bind) {
                            this.cleanupQueue.expect(3 /* Cleanup.ParameterDescription */);
                            this.bindAndExecute(info, preflight.bind, this.parameterDescriptionQueue.shift());
                        }
                        else {
                            this.activeDataHandlerInfo = info;
                        }
                    }
                    this.cleanupQueue.expect(4 /* Cleanup.PreFlight */);
                    break;
                }
                default: {
                    logger.warn(`Message not implemented: ${mtype}`);
                    break;
                }
            }
        }
        return read;
    }
}
exports.Client = Client;
//# sourceMappingURL=client.js.map